## JVM
[toc]

### JVM内存结构


# JVM

## JVM内存结构

![java内存结构](..\\java内存结构.png)

* 方法区

          方法区是一块各个线程共享的区域，主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。根据《Java虚拟机规范》，方法区逻辑上属于堆的一部分，为了和堆区分又叫做非堆（Non-Heap）。
          方法区只是JVM的一个规范，所有虚拟机必须要遵守。但是并没有严格要求如何实现。而在JDK7之前，Hotspot实现的方式是永久代，而在jdk7的时候，已经把原本放在永久代的字符串常量池、静态变量等移到堆中，而到了JDK8完全废弃了永久代的概念，而改为使用与JRockit、J9一样使用元空间来实现方法区。而元空间使用的是本地内存实现的，也就是说它不再受限于Jvm分配内存（jdk7之前使用-XX：MaxPermSize=16m 设置永久代的大小）大小的限制，理论上物理机还有内存就可以分配，这样从一定程度上避免了OutOfMemoryError(OMM）异常。

* 虚拟机栈

  ~~~
      Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈可以理解成我们平时的一个Java方法，每个方法被执行的时候，JAVA虚拟机都会创建一个栈帧用来存放局部变量表、操作数栈、动态链接、方法出口（方法返回）等信息。
  
  1、局部变量表
      局部变量表存放了编译期可知的Java虚拟机的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和returnAddress类型。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量标的大小（这里的大小是指变量槽的数量，而一个变量槽的大小是由虚拟机自行决定的，比如一个槽占用32bit或者64bit或者更多）。
  
  2、操作数栈
      后进先出LIFO，最大深度由编译期确定。栈帧刚建立时，操作数栈为空，执行方法操作时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。操作数栈可以存放一个jvm中定义的任意数据类型的值。在任意时刻，操作数栈都一个固定的栈深度，基本类型除了64位长度的long、double占用两个深度，其它占用一个深度。
  
  3、动态连接
      每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。
  
  4、方法返回地址
      当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令（lreturn、freturn、dreturn以及areturn）或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
      方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。
  
  ~~~

* 本地方法栈

  ~~~
  	本地方法栈与虚拟机栈所发挥的作用是基本一致的，区别在于虚拟机栈执行的是虚拟机中的JAVA方法，而本地方法栈执行的是Native方法。
  ~~~

* 堆

  ~~~
  	JAVA堆是虚拟机所管理内存的最大一块区域，是线程共享的一块区域。而几乎所有的对象实例都是在堆中分配内存。而且堆也是垃圾回收主要回收的区域，堆又被分成“新生代”、“老年代”、“永久代”、“Eden区”、“From Survivor”和“To survivor”。
      默认情况下JVM默认的最大内存-Xmx为物理机内存的1/4，比如我的计算机是24G的那么最大内存大概就是6G，而初始化内存是物理机内存的1/64，也就是384M。
      JVM中堆的空间是可以配置的，使用-Xmx和-Xms可以配置最大内存和初始化内存，但是一般我们会考虑将初始化内存与最大内存设置成一样，避免在初始化内存扩容时发生对象的移动。当然当Java堆中没有足够的空间来存放对象时就会发生OOM异常。
  ~~~

* 程序计数器

  ~~~
  	程序计数器是一块较小的内存空间，几乎可以忽略不计，是运行速度最快的存储区域。它可以理解为当前线程执行的字节码行号。在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。如果是在执行native方法，则是未指定值(undefined)。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下–条需要执行的字节码指令。它是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。
  ~~~

  

* 运行时数据区

* 运行时数据区哪些是线程独享

* 堆和栈区别

* 方法区在不同版本JDK中的位置

* 运行时常量池

* 堆外内存

* TLAB

* Java中的对象一定在堆上分配吗？

### 垃圾回收
## 垃圾回收
* GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收

* GC参数

* 对象存活的判定

* 垃圾收集器（CMS、G1、ZGC、Epsilon）

### JVM参数及调优
## JVM参数及调优
* -Xmx

* -Xmn

* -Xms

* -Xss

* -XX:SurvivorRatio

* -XX:PermSize

* -XX:MaxPermSize

* -XX:MaxTenuringThreshold

### Java对象模型
## Java对象模型
* oop-klass

* 对象头

### HotSpot
## HotSpot
* 即时编译器

* 编译优化

### Java内存模型
## Java内存模型
* 计算机内存模型

* 缓存一致性

* MESI协议

* 可见性

* 原子性

* 顺序性

* happens-before

* as-if-serial

* 内存屏障

* synchronized

* volatile

* final

* 锁

### 虚拟机性能监控与故障处理工具
## 虚拟机性能监控与故障处理工具

* jps

* jstack

* jmap

* jstat

* jconsole

* jinfo

* jhat

* javap

* btrace

* TProfiler

* jlink

* Arthas

### 类加载机制
## 类加载机制

* classLoader

* 类加载过程是线程安全的吗？

* 类加载过程

* 如何判断JVM中类和其他类是不是同一个类

* 双亲委派原则

* 为什么需要双亲委派？

* “父子加载器”之间的关系是继承吗？

* 双亲委派是如何实现的？

* 如何打破双亲委派

* 如何自定义类加载器

* 双亲委派被破坏的例子

* 为什么JNDI，JDBC等需要破坏双亲委派？

* 为什么Tomcat要破坏双亲委派

* 模块化（jboss modules、osgi、jigsaw）

### 打包工具
## 打包工具

* jar

* jlink

* jpackage

### 编译与反编译
## 编译与反编译

* 什么是编译

* 什么是反编译

* Class常量池

* 编译工具：javac

* 反编译工具：javap 、jad 、CRF

### JIT
## JIT

* JIT优化（逃逸分析、栈上分配、标量替换、锁优化）