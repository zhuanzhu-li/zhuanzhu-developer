<h1>Redis集群</h1>

# 一、Redis Cluster

基础配置 **三主三从**

从节点充当冷备

使用 key CRC % 16384（2^14） 得到 slot

slot 分布在集群主节点上，可以不平均分布，手动指定 slot 范围；不通 slot 的key 不能执行 mset 等命令

## 优点

1.  无中心架构，数据按照slot分布在多个节点。
2.  集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。
3.  可线性扩展到1000多个节点，节点可动态添加或删除
4.  能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换

## 缺点

1. 客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception”
 2. 节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的
 3. 数据通过异步复制，不保证数据的强一致性
 4. slave充当“冷备”，不能缓解读压力
 5. 批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好
 6. key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能
 7. 不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0

## slot个数限制

Redis 集群的槽位（Slot）数量设置为 16384（即 2^14），这一设计决策背后有多个技术考量，主要涉及网络通信效率、内存开销、集群规模限制以及历史设计权衡。

1. 网络通信效率：Gossip 协议的数据量优化
集群节点通信：Redis 集群使用 Gossip 协议（心跳消息）交换节点状态信息，其中每个消息会携带节点的槽位分配信息（通过一个 bitmap 表示）。
16384 槽位：每个槽位占用 1 bit，共需 16384 / 8 = 2048 bytes（约 2KB）表示全部槽位。
65536 槽位（2^16）：若槽位数为 65536，则需 65536 / 8 = 8192 bytes（约 8KB）。
高频通信成本：Gossip 消息每秒在节点间频繁交换，2KB vs 8KB 的差异会显著影响网络带宽（尤其在大规模集群中）。选择 16384 在保证分片灵活性的同时，降低了通信开销。
2. 内存占用与性能平衡
节点元数据开销：每个 Redis 节点需要维护集群中所有槽位的映射关系（clusterState.slots 数组）。
16384 槽位：每个槽位存储一个指向节点的指针（如 8 字节），总内存为 16384 * 8B = 128KB。
65536 槽位：同样结构需要 65536 * 8B = 512KB。
内存敏感场景：对于大规模集群（如数百节点），每个节点的元数据内存开销会被放大。16384 在分片粒度和内存占用间取得了平衡。
3. 集群规模限制
官方节点上限：Redis 集群建议的最大节点数为 1000，这一限制与槽位数量共同影响分片逻辑。
槽位分配粒度：16384 允许每个节点平均管理 16384 / 1000 ≈ 16 个槽位，避免单个节点负载过轻或过重。
扩容灵活性：槽位数量足够多（远大于节点数），使得数据分片可以灵活调整（如增删节点时迁移部分槽位）。
4. 哈希函数与冲突概率
CRC16 哈希算法：Redis 使用 CRC16(key) mod 16384 计算键的槽位。
哈希空间：CRC16 的输出范围为 0~65535（2^16），但最终取模到 16384（2^14），相当于将哈希空间压缩了 4 倍。
冲突概率：虽然槽位数为 16384，但哈希值的原始空间更大（65536），实际冲突概率极低，足够满足大多数场景需求。
5. 历史设计与兼容性
设计初衷：Redis 作者 Salvatore Sanfilippo（Antirez）在早期权衡了不同槽位数的利弊，最终选择 16384 作为合理折中。
兼容性考虑：即使后续有提议增加槽位数（如 65536），但修改会影响现有集群的协议和工具链，因此保持历史设计更稳定。

# 二、Redis 主从

# 三、Redis哨兵

