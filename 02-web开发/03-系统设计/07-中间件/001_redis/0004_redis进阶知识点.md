[toc]

# 1. 布隆过滤器

参考：[布隆过滤器Bloom Filter简介](https://blog.csdn.net/qq_55624813/article/details/121316520)

**使用场景**

* 判断一个元素是否在一个集合中。 常见的查找方式以及时间复杂度
    - 采用 *线性表* 存储，查找时间复杂度为 O(n)
    - 采用 *平衡二叉排序树*（AVL、红黑树），查找时间复杂度为 O(log n)
    - 采用 *哈希表*, 查找时间复杂度为 O(log (n/m))

当需要查找海量数据时，不仅耗时较长，也会占用大量的存储空间，而这就有**布隆过滤器**的应用场景

## 1.1 简述

* 布隆过滤器是一种数据结构，用于检索集合中是否包含特定元素；
* 布隆过滤器由一个长度为 `m bit` 的位数组和 k 个独立的hash函数构成；
* 位数组初始化均为0，所有的hash会将输入数据尽量均匀分布在位数组中；
* 向布隆过滤器中插入一个元素时，会通过k个hash函数计算出k个hash值，并将位数组中的以hash值为下标的k位置为1；
* 查找一个元素时，同样通过k个hash函数计算出k个hash值，并比较下标中对应的值；
* 判断是否存在的依据就是，如果k个位置中有一个为0，则可以判断查找的元素不存在于布隆过滤器中；
* 由于存在hash冲突，因此，如果判断元素不存在于布隆过滤器中，则一定不在，但如果存在，则无法完全判定元素存在于布隆过滤器中。

## 1.2 优缺点

* 优点
    * 节省空间
    * 时间复杂度低， O(k)，k为hash函数个数
* 缺点
    * 假阳问题
    * 不支持删除元素

## 1.3 选参

假设E表示错误率，n表示要插入的元素个数，m表示bit数组的长度，k表示hash函数的个数。

1. 当hash函数个数 k = (ln2) * (m/n)时，错误率E最小（此时bit数组中有一半的值为0）
2. 在错误率不大于E的情况下，bit数组的长度m需要满足的条件为：m ≥ n * lg(1/E)。
3. 结合上面两个公式，在hash函数个数k取到最优时，要求错误率不大于E，这时我们对bit数组长度m的要求是：m>=nlg(1/E) * lg(e) ，也就是 m ≥ 1.44n*lg(1/E)（lg表示以2为底的对数）

## 1.4 解决无法删除元素的问题
* 计数 <br/>
  在插入元素时，拓展一个计数器 <br/>
![img.png](../../99_source/img/img.png)

* 布谷鸟过滤器
# 2. hash一致性算法



